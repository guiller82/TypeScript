{"version":3,"sources":["System/Collections/LinkedNodeList.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAEH,2CAAuC;AACvC,qFAAkF;AAClF,qEAAkE;AAClE,6EAA0E;AAC1E,+DAA4D;AAQ5D,yCAA4C;AAC5C,oCAAoC;AACpC,IAAM,SAAS,GAAG,iBAAe,CAAC;AAGlC;;;;;;;+BAO+B;AAE/B;;;;;;;;GAQG;AACH;IAQC;QAEC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;IACnB,CAAC;IAID,sCAAa,GAAb,UAAc,OAAc;QAE3B,IAAG,OAAO,KAAG,IAAI,CAAC,QAAQ;YACzB,MAAM,IAAI,qDAAyB,CAAC,0BAA0B,CAAC,CAAC;QACjE,OAAO,IAAI,CAAC;IACb,CAAC;IAKD,sBAAI,iCAAK;QAHT;;WAEG;aACH;YAEC,OAAO,IAAI,CAAC,MAAM,CAAC;QACpB,CAAC;;;OAAA;IAKD,sBAAI,gCAAI;QAHR;;WAEG;aACH;YAEC,OAAO,IAAI,CAAC,KAAK,CAAC;QACnB,CAAC;;;OAAA;IAOD,sBAAI,iCAAK;QAJT;;;WAGG;aACH;YAGC,IAAI,IAAI,GAAwB,IAAI,CAAC,MAAM,CAAC;YAE5C,IAAI,CAAC,GAAU,CAAC,CAAC;YACjB,OAAM,IAAI,EACV;gBACC,CAAC,EAAE,CAAC;gBACJ,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;aACjB;YAED,OAAO,CAAC,CAAC;QACV,CAAC;;;OAAA;IAQD,gCAAO,GAAP,UACC,MAAyD,EAAE,gBAAyB;QAEpF,IAAM,CAAC,GAAG,IAAI,CAAC;QACf,IAAI,OAAO,GAAwB,IAAI,EACnC,IAAI,GAAwB,CAAC,CAAC,KAAK,CAAC,CAAC,gEAAgE;QAEzG,IAAM,OAAO,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC3B,IAAI,KAAK,GAAU,CAAC,CAAC;QACrB,GAAG;YACF,IAAG,CAAC,gBAAgB;gBAAE,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAC/C,OAAO,GAAG,IAAI,CAAC;YACf,IAAI,GAAG,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC;SAC/B,QACK,OAAO;eACL,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,KAAG,KAAK,EAAE;QAE1C,OAAO,KAAK,CAAC;IACd,CAAC;IAID,4BAAG,GAAH,UAAO,QAAmC;QAEzC,IAAG,CAAC,QAAQ;YAAE,MAAM,IAAI,6CAAqB,CAAC,UAAU,CAAC,CAAC;QAE1D,IAAM,MAAM,GAAO,EAAE,CAAC;QACtB,IAAI,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,CAAC;YAEpB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IACf,CAAC;IAED;;;OAGG;IACH,8BAAK,GAAL;QAEC,IAAM,CAAC,GAAG,IAAI,CAAC;QACf,IAAI,CAAsB,EAAE,EAAE,GAAU,CAAC,EAAE,EAAE,GAAU,CAAC,CAAC;QAEzD,yCAAyC;QACzC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;QACb,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;QAEhB,OAAM,CAAC,EACP;YACC,EAAE,EAAE,CAAC;YACL,IAAI,OAAO,GAAG,CAAC,CAAC;YAChB,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;YACX,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;SACpB;QAED,wCAAwC;QACxC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;QACZ,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;QAEf,OAAM,CAAC,EACP;YACC,EAAE,EAAE,CAAC;YACL,IAAI,OAAO,GAAG,CAAC,CAAC;YAChB,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC;YACf,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC;SACxB;QAED,IAAG,EAAE,KAAG,EAAE;YAAE,OAAO,CAAC,IAAI,CAAC,sFAAsF,GAAG,EAAE,GAAG,aAAa,GAAG,EAAE,CAAC,CAAC;QAE3I,CAAC,CAAC,QAAQ,EAAE,CAAC;QACb,CAAC,CAAC,WAAW,GAAG,CAAC,CAAC;QAElB,OAAO,EAAE,CAAC;IACX,CAAC;IAED;;OAEG;IACH,gCAAO,GAAP;QAEC,IAAI,CAAC,KAAK,EAAE,CAAC;IACd,CAAC;IAED;;;;OAIG;IACH,iCAAQ,GAAR,UAAS,IAAU;QAElB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAG,CAAC,CAAC,CAAC;IAChC,CAAC;IAGD;;;OAGG;IACH,kCAAS,GAAT,UAAU,KAAY;QAErB,IAAG,KAAK,GAAC,CAAC;YACT,OAAO,IAAI,CAAC;QAEb,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QAEvB,IAAI,CAAC,GAAU,CAAC,CAAC;QACjB,OAAM,IAAI,IAAI,CAAC,EAAE,GAAC,KAAK,EACvB;YACC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;SACzB;QAED,OAAO,IAAI,CAAC;IAEb,CAAC;IAED,6BAAI,GAAJ,UAAK,SAAmC;QAEvC,IAAI,IAAI,GAAc,IAAI,CAAC;QAC3B,IAAI,CAAC,OAAO,CAAC,UAAC,CAAC,EAAE,CAAC;YAEjB,IAAG,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAClB;gBACC,IAAI,GAAG,CAAC,CAAC;gBACT,OAAO,KAAK,CAAC;aACb;QACF,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;OAIG;IACH,gCAAO,GAAP,UAAQ,IAAU;QAEjB,IAAG,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,EACvC;YAEC,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,IAAI,CAAC,SAAqB,EACtB,CAAC,GAAwB,IAAI,CAAC,MAAM,CAAC;YAEzC,GAAG;gBACF,CAAC,GAAG,CAAC,CAAC;gBACN,IAAG,CAAC,KAAG,IAAI;oBAAE,OAAO,KAAK,CAAC;gBAC1B,KAAK,EAAE,CAAC;aACR,QACK,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE;SACzB;QAED,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;;OAGG;IACH,oCAAW,GAAX;QAEC,OAAO,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACtD,CAAC;IAED;;;OAGG;IACH,mCAAU,GAAV;QAEC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpD,CAAC;IAGD;;;;;OAKG;IACH,mCAAU,GAAV,UAAW,IAAU;QAEpB,IAAG,IAAI,IAAE,IAAI;YACZ,MAAM,IAAI,6CAAqB,CAAC,MAAM,CAAC,CAAC;QAEzC,IAAM,CAAC,GAAG,IAAI,CAAC;QACf,IAAM,IAAI,GAAc,IAAI,CAAC,QAAQ,IAAI,IAAI,EACvC,IAAI,GAAc,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;QAE1C,IAAI,CAAC,GAAW,KAAK,EACjB,CAAC,GAAW,KAAK,CAAC;QAEtB,IAAG,IAAI;YAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;aACrB,IAAG,CAAC,CAAC,MAAM,IAAE,IAAI;YAAE,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;;YACnC,CAAC,GAAG,IAAI,CAAC;QAEd,IAAG,IAAI;YAAE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;aACzB,IAAG,CAAC,CAAC,KAAK,IAAE,IAAI;YAAE,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;;YACjC,CAAC,GAAG,IAAI,CAAC;QAEd,IAAG,CAAC,KAAG,CAAC,EACR;YACC,MAAM,IAAI,qCAAiB,CAC1B,MAAM,EAAE,gBAAM,CACb,gEAAgE,EAChE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAC7C,CACD,CAAC;SACF;QAED,IAAM,OAAO,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QACzB,IAAG,OAAO,EACV;YACC,CAAC,CAAC,QAAQ,EAAE,CAAC;YACb,CAAC,CAAC,WAAW,EAAE,CAAC;YAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACjB;QACD,OAAO,OAAO,CAAC;IAEhB,CAAC;IAED;;;;OAIG;IACH,gCAAO,GAAP,UAAQ,IAAU;QAEjB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QACxB,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;;;OAMG;IACH,sCAAa,GAAb,UAAc,IAAU,EAAE,MAAwB;QAAxB,uBAAA,EAAA,aAAwB;QAEjD,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAE1B,IAAM,CAAC,GAAG,IAAI,CAAC;QAEf,IAAG,CAAC,MAAM,EACV;YACC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;SAClB;QAED,IAAG,MAAM,EACT;YACC,IAAI,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC;YAC3B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC;YAEnB,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC;YACvB,IAAG,IAAI;gBAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YAC1B,IAAG,MAAM,IAAE,CAAC,CAAC,MAAM;gBAAE,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;SACrC;aAED;YACC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;SAC1B;QAED,CAAC,CAAC,QAAQ,EAAE,CAAC;QACb,CAAC,CAAC,WAAW,EAAE,CAAC;QAEhB,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;;;OAMG;IACH,qCAAY,GAAZ,UAAa,IAAU,EAAE,KAAuB;QAAvB,sBAAA,EAAA,YAAuB;QAE/C,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAC1B,IAAM,CAAC,GAAG,IAAI,CAAC;QAEf,IAAG,CAAC,KAAK,EACT;YACC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;SAChB;QAED,IAAG,KAAK,EACR;YACC,IAAI,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;YACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YAEtB,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;YAClB,IAAG,IAAI;gBAAE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YAC9B,IAAG,KAAK,IAAE,CAAC,CAAC,KAAK;gBAAE,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;SAClC;aAED;YACC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;SAC1B;QAED,CAAC,CAAC,QAAQ,EAAE,CAAC;QACb,CAAC,CAAC,WAAW,EAAE,CAAC;QAEhB,OAAO,CAAC,CAAC;IACV,CAAC;IAED;;;;;OAKG;IACH,gCAAO,GAAP,UAAQ,IAAU,EAAE,WAAiB;QAGpC,IAAG,IAAI,IAAE,IAAI;YACZ,MAAM,IAAI,6CAAqB,CAAC,MAAM,CAAC,CAAC;QAEzC,IAAG,IAAI,IAAE,WAAW;YAAE,OAAO,IAAI,CAAC;QAElC,mBAAmB,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;QAEhD,IAAM,CAAC,GAAG,IAAI,CAAC;QACf,WAAW,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QACrC,WAAW,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAE7B,IAAG,IAAI,CAAC,QAAQ;YAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,WAAW,CAAC;QACnD,IAAG,IAAI,CAAC,IAAI;YAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC;QAE/C,IAAG,IAAI,IAAE,CAAC,CAAC,MAAM;YAAE,CAAC,CAAC,MAAM,GAAG,WAAW,CAAC;QAC1C,IAAG,IAAI,IAAE,CAAC,CAAC,KAAK;YAAE,CAAC,CAAC,KAAK,GAAG,WAAW,CAAC;QAExC,CAAC,CAAC,QAAQ,EAAE,CAAC;QAEb,OAAO,CAAC,CAAC;IACV,CAAC;IAEM,kCAAmB,GAA1B,UAA8B,IAA4C;QAGzE,IAAG,CAAC,IAAI;YAAE,MAAM,IAAI,6CAAqB,CAAC,MAAM,CAAC,CAAC;QAElD,IAAI,OAA8C,EAC9C,IAA2C,EAC3C,OAAc,CAAC;QAEnB,OAAO,IAAI,+BAAc,CACxB;YAEC,uBAAuB;YACvB,OAAO,GAAG,IAAI,CAAC;YACf,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;YAClB,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC,EACD,UAAC,OAAO;YAEP,IAAG,IAAI,EACP;gBACC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;gBAE5B,OAAO,GAAG,IAAI,CAAC;gBACf,IAAI,GAAG,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC;gBAC/B,OAAO,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aAC1C;YAED,OAAO,OAAO,CAAC,UAAU,EAAE,CAAC;QAC7B,CAAC,CACD,CAAC;IACH,CAAC;IAEM,yBAAU,GAAjB,UACC,IAA4C,EAC5C,KAAkB,EAClB,KAAgB;QAAhB,sBAAA,EAAA,SAAgB;QAEhB,IAAG,IAAI,IAAI,IAAI,CAAC,KAAK,EACrB;YACC,IAAG,CAAC,KAAK;gBAAE,MAAM,IAAI,6CAAqB,CAAC,OAAO,CAAC,CAAC;YAEpD,IAAI,CAAC,OAAO,CACX,UAAC,IAAI,EAAE,CAAC;gBAEP,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;YAC/B,CAAC,CACD,CAAC;SACF;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAEF,qBAAC;AAAD,CA5cA,AA4cC,IAAA;AA5cY,wCAAc;AA8c3B,6BACC,IAAU,EACV,QAAwB;IAAxB,yBAAA,EAAA,iBAAwB;IAGxB,IAAG,IAAI,IAAE,IAAI;QACZ,MAAM,IAAI,6CAAqB,CAAC,QAAQ,CAAC,CAAC;IAE3C,IAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ;QAC5B,MAAM,IAAI,qDAAyB,CAAC,+DAA+D,CAAC,CAAC;AAEvG,CAAC;AAED,kBAAe,cAAc,CAAC","file":"LinkedNodeList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {format} from \"../Text/Utility\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {EnumeratorBase} from \"./Enumeration/EnumeratorBase\";\r\nimport {ILinkedNode, ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerateEach} from \"./Enumeration/IEnumerateEach\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\nimport {ILinkedNodeList} from \"./ILinkedList\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {ActionWithIndex, PredicateWithIndex, Selector, SelectorWithIndex} from \"../FunctionTypes\";\r\nimport {ArrayLikeWritable} from \"./Array/ArrayLikeWritable\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport class LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IEnumerateEach<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode|null;\r\n\tprivate _last:TNode|null;\r\n\tunsafeCount:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t\tthis.unsafeCount = 0;\r\n\t\tthis._version = 0;\r\n\t}\r\n\r\n\tprivate _version:number;\r\n\r\n\tassertVersion(version:number):true|never\r\n\t{\r\n\t\tif(version!==this._version)\r\n\t\t\tthrow new InvalidOperationException(\"Collection was modified.\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t */\r\n\tget first():TNode|null\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t */\r\n\tget last():TNode|null\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\r\n\t\tlet next:TNode|null|undefined = this._first;\r\n\r\n\t\tlet i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t// Note, no need for 'useCopy' since this avoids any modification conflict.\r\n\t// If iterating over a arrayCopy is necessary, a arrayCopy should be made manually.\r\n\tforEach(\r\n\t\taction:ActionWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\tforEach(\r\n\t\taction:PredicateWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\tforEach(\r\n\t\taction:ActionWithIndex<TNode> | PredicateWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet current:TNode|null|undefined = null,\r\n\t\t    next:TNode|null|undefined = _.first; // Be sure to track the next node so if current node is removed.\r\n\r\n\t\tconst version = _._version;\r\n\t\tlet index:number = 0;\r\n\t\tdo {\r\n\t\t\tif(!ignoreVersioning) _.assertVersion(version);\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current && current.next;\r\n\t\t}\r\n\t\twhile(current\r\n\t\t&& <any>action(current, index++)!==false);\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\tmap<T>(selector:Selector<TNode,T>):T[]\r\n\tmap<T>(selector:SelectorWithIndex<TNode,T>):T[]\r\n\tmap<T>(selector:SelectorWithIndex<TNode,T>):T[]\r\n\t{\r\n\t\tif(!selector) throw new ArgumentNullException('selector');\r\n\r\n\t\tconst result:T[] = [];\r\n\t\tthis.forEach((node, i)=>\r\n\t\t{\r\n\t\t\tresult.push(selector(node, i));\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet n:TNode|null|undefined, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcF++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.next;\r\n\t\t\tcurrent.next = null;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcL++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.previous;\r\n\t\t\tcurrent.previous = null;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount = 0;\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!= -1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t */\r\n\tgetNodeAt(index:number):TNode|null\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tlet next = this._first;\r\n\r\n\t\tlet i:number = 0;\r\n\t\twhile(next && i++<index)\r\n\t\t{\r\n\t\t\tnext = next.next || null;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tfind(condition:PredicateWithIndex<TNode>):TNode|null\r\n\t{\r\n\t\tlet node:TNode|null = null;\r\n\t\tthis.forEach((n, i)=>\r\n\t\t{\r\n\t\t\tif(condition(n, i))\r\n\t\t\t{\r\n\t\t\t\tnode = n;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number\r\n\t{\r\n\t\tif(node && (node.previous || node.next))\r\n\t\t{\r\n\r\n\t\t\tlet index = 0;\r\n\t\t\tlet c:TNode|null|undefined,\r\n\t\t\t    n:TNode|null|undefined = this._first;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tc = n;\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\twhile((n = c && c.next));\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn !!this._first && this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn !!this._last && this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tconst _ = this;\r\n\t\tconst prev:TNode|null = node.previous || null,\r\n\t\t      next:TNode|null = node.next || null;\r\n\r\n\t\tlet a:boolean = false,\r\n\t\t    b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst removed = !a && !b;\r\n\t\tif(removed)\r\n\t\t{\r\n\t\t\t_._version++;\r\n\t\t\t_.unsafeCount--;\r\n\t\t\tnode.previous = null;\r\n\t\t\tnode.next = null;\r\n\t\t}\r\n\t\treturn removed;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t * @returns {LinkedNodeList}\r\n\t */\r\n\taddNode(node:TNode):this\r\n\t{\r\n\t\tthis.addNodeAfter(node);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t * @returns {LinkedNodeList}\r\n\t */\r\n\taddNodeBefore(node:TNode, before:TNode|null = null):this\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!before)\r\n\t\t{\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before)\r\n\t\t{\r\n\t\t\tlet prev = before.previous;\r\n\t\t\tnode.previous = prev;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(prev) prev.next = node;\r\n\t\t\tif(before==_._first) _._first = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount++;\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t * @returns {LinkedNodeList}\r\n\t */\r\n\taddNodeAfter(node:TNode, after:TNode|null = null):this\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!after)\r\n\t\t{\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after)\r\n\t\t{\r\n\t\t\tlet next = after.next;\r\n\t\t\tnode.next = next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(next) next.previous = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount++;\r\n\r\n\t\treturn _;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t * @returns {any}\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):this\r\n\t{\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tif(node==replacement) return this;\r\n\r\n\t\tassertValidDetached(replacement, 'replacement');\r\n\r\n\t\tconst _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\r\n\t\t_._version++;\r\n\r\n\t\treturn _;\r\n\t}\r\n\r\n\tstatic valueEnumeratorFrom<T>(list:LinkedNodeList<ILinkedNodeWithValue<T>>):IEnumerator<T>\r\n\t{\r\n\r\n\t\tif(!list) throw new ArgumentNullException('list');\r\n\r\n\t\tlet current:ILinkedNodeWithValue<T>|null|undefined,\r\n\t\t    next:ILinkedNodeWithValue<T>|null|undefined,\r\n\t\t    version:number;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = list.first;\r\n\t\t\t\tversion = list._version;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.assertVersion(version);\r\n\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic copyValues<T,TDestination extends ArrayLikeWritable<any>>(\r\n\t\tlist:LinkedNodeList<ILinkedNodeWithValue<T>>,\r\n\t\tarray:TDestination,\r\n\t\tindex:number = 0):TDestination\r\n\t{\r\n\t\tif(list && list.first)\r\n\t\t{\r\n\t\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t\tlist.forEach(\r\n\t\t\t\t(node, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = node.value;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(\r\n\tnode:TNode,\r\n\tpropName:string = 'node')\r\n{\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}\r\n\r\nexport default LinkedNodeList;"]}