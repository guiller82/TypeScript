{"version":3,"sources":["System/Collections/MapUtility.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAIH;;;;;GAKG;AACH,eACC,MAAQ,EACR,MAAQ;IAER,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;IAChC,KAAI,IAAM,GAAG,IAAI,MAAM,EACvB;QACC,IAAG,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAC7B;YACC,MAAM,CAAC,GAAG,CAAC,GAAS,MAAO,CAAC,GAAG,CAAC,CAAC;SACjC;KACD;IACD,OAAO,MAAM,CAAC;AACf,CAAC;AAbD,sBAaC;AAED;;;;;GAKG;AACH,gBACC,MAAQ,EACR,QAAU;IAEV,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;IAChC,KAAI,IAAM,GAAG,IAAI,QAAQ,EACzB;QACC,IAAG,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAC9D;YACC,MAAM,CAAC,GAAG,CAAC,GAAS,QAAS,CAAC,GAAG,CAAC,CAAC;SACnC;KACD;IACD,OAAO,MAAM,CAAC;AACf,CAAC;AAbD,wBAaC;AAED;;;;GAIG;AACH,cAA0C,MAAQ;IAEjD,OAAO,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;AAC1B,CAAC;AAHD,oBAGC;AAGD;;;;;GAKG;AACH,eACC,CAAG,EACH,CAAG;IAEH,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1B,CAAC;AALD,sBAKC;AAED;;;;GAIG;AACH,cAAgD,MAAgB,EAAE,MAAc;IAE/E,KAAI,IAAM,GAAG,IAAI,MAAM,EACvB;QACC,IAAG,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAC9B;YACC,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;SACnB;KACD;IACD,qBAAqB;AACtB,CAAC;AAVD,oBAUC;AAED,cAAqB,GAAa,EAAE,KAAgB;IAAhB,sBAAA,EAAA,SAAgB;IAEnD,IAAG,GAAG,IAAI,KAAK,EACf;QACC,KAAe,UAAgB,EAAhB,KAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAhB,cAAgB,EAAhB,IAAgB,EAC/B;YADI,IAAI,GAAG,SAAA;YAEV,IAAM,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;YACnB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;YAChB,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;SACnB;KACD;AACF,CAAC;AAXD,oBAWC","file":"MapUtility.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {IMap} from \"../../IMap\";\r\n\r\n/**\r\n * Takes a target object and applies all source values to it.\r\n * @param target\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function apply<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tsource:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in source)\r\n\t{\r\n\t\tif(source.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>source)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes a target object and ensures values exist.\r\n * @param target\r\n * @param defaults\r\n * @returns {any}\r\n */\r\nexport function ensure<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tdefaults:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in defaults)\r\n\t{\r\n\t\tif(defaults.hasOwnProperty(key) && !result.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>defaults)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Make a copy of the source object.\r\n * @param source\r\n * @returns {Object}\r\n */\r\nexport function copy<T extends IMap<any>>(source:T):T\r\n{\r\n\treturn apply({}, source);\r\n}\r\n\r\n\r\n/**\r\n * Takes two objects and creates another with the values of both.\r\n * B overwrites A.\r\n * @param a\r\n * @param b\r\n */\r\nexport function merge<A extends IMap<any>, B extends IMap<any>>(\r\n\ta:A,\r\n\tb:B):A & B\r\n{\r\n\treturn apply(copy(a), b);\r\n}\r\n\r\n/**\r\n * Removes any keys that don't exist on the keyMap.\r\n * @param target\r\n * @param keyMap\r\n */\r\nexport function trim<TResult extends IMap<any>>(target:IMap<any>, keyMap:TResult):void //Partial<TResult>\r\n{\r\n\tfor(const key in target)\r\n\t{\r\n\t\tif(!keyMap.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tdelete target[key];\r\n\t\t}\r\n\t}\r\n\t//return <any>target;\r\n}\r\n\r\nexport function wipe(map:IMap<any>, depth:number = 1):void\r\n{\r\n\tif(map && depth)\r\n\t{\r\n\t\tfor(let key of Object.keys(map))\r\n\t\t{\r\n\t\t\tconst v = map[key];\r\n\t\t\tdelete map[key];\r\n\t\t\twipe(v, depth - 1);\r\n\t\t}\r\n\t}\r\n}"]}