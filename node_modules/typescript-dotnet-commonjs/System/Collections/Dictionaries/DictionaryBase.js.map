{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.ts"],"names":[],"mappings":"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","file":"DictionaryBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport {forEach} from \"../Enumeration/Enumerator\";\r\nimport {CollectionBase} from \"../CollectionBase\";\r\nimport {EnumeratorBase} from \"../Enumeration/EnumeratorBase\";\r\nimport {ArgumentNullException} from \"../../Exceptions/ArgumentNullException\";\r\nimport {InvalidOperationException} from \"../../Exceptions/InvalidOperationException\";\r\nimport {extractKeyValue} from \"../../KeyValueExtract\";\r\nimport {IKeyValuePair, KeyValuePair} from \"../../KeyValuePair\";\r\nimport {IDictionary} from \"./IDictionary\";\r\nimport {IEnumerator} from \"../Enumeration/IEnumerator\";\r\nimport {IEnumerableOrArray} from \"../IEnumerableOrArray\";\r\nimport __extendsImport from \"../../../extends\";\r\nimport {KeyNotFoundException} from \"../KeyNotFoundException\";\r\nimport {Action} from \"../../FunctionTypes\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nexport abstract class DictionaryBase<TKey, TValue>\r\nextends CollectionBase<IKeyValuePair<TKey,TValue>> implements IDictionary<TKey, TValue>\r\n{\r\n\tprotected constructor(source?:IEnumerableOrArray<IKeyValuePair<TKey,TValue>>)\r\n\t{\r\n\t\tsuper(source);\r\n\t}\r\n\r\n\r\n\t//noinspection JSUnusedLocalSymbols\r\n\tprotected _onValueModified(key:TKey, value:TValue|undefined, old:TValue|undefined):void\r\n\t{\r\n\t}\r\n\r\n\tprotected _addInternal(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) => this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet count = 0;\r\n\r\n\t\tfor(let key of _.keys)\r\n\t\t{\r\n\t\t\tif(_.removeByKey(key)) count++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item || !this.getCount()) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) =>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tprotected _removeInternal(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) =>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot add 'undefined' as a value.\");\r\n\r\n\t\tconst _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tconst ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\treturn _.setValue(key, value);\r\n\t}\r\n\r\n\tprotected abstract _getEntry(key:TKey):IKeyValuePair<TKey,TValue>|null;\r\n\r\n\tabstract getValue(key:TKey):TValue|undefined;\r\n\r\n\tgetAssuredValue(key:TKey):TValue\r\n\t{\r\n\t\tconst value = this.getValue(key);\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new KeyNotFoundException(`Key '${key}' not found.`);\r\n\t\treturn value;\r\n\t}\r\n\r\n\ttryGetValue(key:TKey, out:Action<TValue>):boolean\r\n\t{\r\n\t\tconst value = this.getValue(key);\r\n\t\tif(value!==VOID0)\r\n\t\t{\r\n\t\t\tout(value);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected abstract _setValueInternal(key:TKey, value:TValue|undefined):boolean;\r\n\r\n\t/**\r\n\t * Sets the value of an entry.\r\n\t * It's important to know that 'undefined' cannot exist as a value in the dictionary and is used as a flag for removal.\r\n\t * @param key\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\tsetValue(key:TKey, value:TValue|undefined):boolean\r\n\t{\r\n\t\t// setValue shouldn't need to worry about recursion...\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\tlet changed = false;\r\n\t\tconst old = _.getValue(key); // get the old value here and pass to internal.\r\n\t\tif(!areEqual(value, old) && _._setValueInternal(key, value))\r\n\t\t{\r\n\t\t\tchanged = true;\r\n\t\t\t_._onValueModified(key, value, old)\r\n\t\t}\r\n\r\n\t\t_._signalModification(changed);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\treturn !!this._getEntry(key);\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tconst e = this.getEnumerator();\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(areEqual(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, VOID0);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet count = 0;\r\n\t\tfor(let key of _.getKeys())\r\n\t\t{\r\n\t\t\tif(areEqual(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>|IEnumerator<KeyValuePair<TKey, TValue>>|null|undefined):number\r\n\t{\r\n\t\t// Allow piping through to trigger onModified properly.\r\n\t\treturn super.importEntries(<any>pairs);\r\n\t}\r\n\r\n\tprotected _importEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>|IEnumerator<KeyValuePair<TKey, TValue>>|null|undefined):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(!pairs) return 0;\r\n\t\tlet changed:number = 0;\r\n\t\tforEach(pairs,\r\n\t\t\tpair => extractKeyValue(pair, (key, value) =>\r\n\t\t\t{\r\n\t\t\t\tif(_._setValueInternal(key, value))\r\n\t\t\t\t\tchanged++;\r\n\t\t\t})\r\n\t\t);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet ver:number, keys:TKey[], len:number, index = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\tver = _._version; // Track the version since getKeys is a copy.\r\n\t\t\t\tkeys = _.getKeys();\r\n\t\t\t\tlen = keys.length;\r\n\t\t\t},\r\n\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t_.assertVersion(ver);\r\n\r\n\t\t\t\twhile(index<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst key = keys[index++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}