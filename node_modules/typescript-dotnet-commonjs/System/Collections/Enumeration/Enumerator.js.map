{"version":3,"sources":["System/Collections/Enumeration/Enumerator.ts"],"names":[],"mappings":"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","file":"Enumerator.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {using} from \"../../Disposable/dispose\";\r\nimport {Type} from \"../../Types\";\r\nimport {ArrayEnumerator} from \"./ArrayEnumerator\";\r\nimport {IndexEnumerator} from \"./IndexEnumerator\";\r\nimport {UnsupportedEnumerableException} from \"./UnsupportedEnumerableException\";\r\nimport {ActionWithIndex, PredicateWithIndex, SelectorWithIndex} from \"../../FunctionTypes\";\r\nimport {IEnumerator} from \"./IEnumerator\";\r\nimport {IEnumerable} from \"./IEnumerable\";\r\nimport {IEnumerableOrArray} from \"../IEnumerableOrArray\";\r\nimport {InfiniteEnumerator, InfiniteValueFactory} from \"./InfiniteEnumerator\";\r\nimport {EmptyEnumerator as Empty} from \"./EmptyEnumerator\";\r\nimport {IIterator, IIteratorResult} from \"./IIterator\";\r\nimport {IteratorEnumerator} from \"./IteratorEnumerator\";\r\nimport {ForEachEnumerable} from \"./ForEachEnumerable\";\r\n\r\n\r\nconst\r\n\tSTRING_EMPTY:string       = \"\",\r\n\tENDLESS_EXCEPTION_MESSAGE =\r\n\t\t'Cannot call forEach on an endless enumerable. ' +\r\n\t\t'Would result in an infinite loop that could hang the current process.';\r\n\r\nexport function throwIfEndless(isEndless:false):true\r\nexport function throwIfEndless(isEndless:true):never\r\nexport function throwIfEndless(isEndless:boolean|undefined):true|never\r\nexport function throwIfEndless(isEndless:boolean|undefined):true|never\r\n{\r\n\tif(isEndless)\r\n\t\tthrow new UnsupportedEnumerableException(ENDLESS_EXCEPTION_MESSAGE);\r\n\treturn true;\r\n}\r\n\r\nfunction initArrayFrom(\r\n\tsource:ForEachEnumerable<any>,\r\n\tmax:number = Infinity):any[]\r\n{\r\n\tif(Type.isArrayLike(source))\r\n\t{\r\n\t\tconst len = Math.min(source.length, max);\r\n\t\tif(isFinite(len))\r\n\t\t{\r\n\t\t\tif(len>65535) return new Array(len);\r\n\t\t\tconst result:any[] = [];\r\n\t\t\tresult.length = len;\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\treturn [];\r\n}\r\n\r\n\r\n// Could be array, or IEnumerable...\r\n\r\n/**\r\n * Returns the enumerator for the specified collection, enumerator, or iterator.\r\n * If the source is identified as IEnumerator it will return the source as is.\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function from<T>(source:ForEachEnumerable<T>|InfiniteValueFactory<T>):IEnumerator<T>\r\n{\r\n\t// To simplify and prevent null reference exceptions:\r\n\tif(!source)\r\n\t\treturn Empty;\r\n\r\n\tif((source)instanceof(Array))\r\n\t\treturn new ArrayEnumerator<T>(<T[]>source);\r\n\r\n\tif(Type.isArrayLike<T>(source))\r\n\t{\r\n\t\treturn new IndexEnumerator<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tsource: source,\r\n\t\t\t\t\tlength: source.length,\r\n\t\t\t\t\tpointer: 0,\r\n\t\t\t\t\tstep: 1\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tif(!Type.isPrimitive(source))\r\n\t{\r\n\t\tif(isEnumerable<T>(source))\r\n\t\t\treturn source.getEnumerator();\r\n\r\n\t\tif(Type.isFunction(source))\r\n\t\t\treturn new InfiniteEnumerator(source);\r\n\r\n\t\tif(isEnumerator<T>(source))\r\n\t\t\treturn source;\r\n\r\n\t\tif(isIterator<T>(source))\r\n\t\t\treturn new IteratorEnumerator<T>(source);\r\n\r\n\t}\r\n\r\n\tthrow new UnsupportedEnumerableException();\r\n}\r\n\r\nexport function isEnumerable<T>(instance:any):instance is IEnumerable<T>\r\n{\r\n\treturn Type.hasMemberOfType<IEnumerable<T>>(instance, \"getEnumerator\", Type.FUNCTION);\r\n}\r\n\r\nexport function isEnumerableOrArrayLike<T>(instance:any):instance is IEnumerableOrArray<T>\r\n{\r\n\treturn Type.isArrayLike(instance) || isEnumerable(instance);\r\n}\r\n\r\nexport function isEnumerator<T>(instance:any):instance is IEnumerator<T>\r\n{\r\n\treturn Type.hasMemberOfType<IEnumerator<T>>(instance, \"moveNext\", Type.FUNCTION);\r\n}\r\n\r\nexport function isIterator<T>(instance:any):instance is IIterator<T>\r\n{\r\n\treturn Type.hasMemberOfType<IIterator<T>>(instance, \"next\", Type.FUNCTION);\r\n}\r\n\r\n/**\r\n * Flexible method for iterating any enumerable, enumerable, iterator, array, or array-like object.\r\n * @param e The enumeration to loop on.\r\n * @param action The action to take on each.\r\n * @param max Stops after max is reached.  Allows for forEach to be called on infinite enumerations.\r\n * @returns the total times iterated.  If the enumerable is unrecognized then -1.\r\n */\r\n\r\nexport function forEach<T>(\r\n\te:ForEachEnumerable<T>,\r\n\taction:ActionWithIndex<T>,\r\n\tmax?:number):number\r\n\r\nexport function forEach<T>(\r\n\te:ForEachEnumerable<T>,\r\n\taction:PredicateWithIndex<T>,\r\n\tmax?:number):number\r\n\r\nexport function forEach<T>(\r\n\te:ForEachEnumerable<T>,\r\n\taction:ActionWithIndex<T> | PredicateWithIndex<T>,\r\n\tmax:number = Infinity):number\r\n{\r\n\tif(<any>e===STRING_EMPTY) return 0;\r\n\r\n\tif(e && max>0)\r\n\t{\r\n\t\tif(Type.isArrayLike<T>(e))\r\n\t\t{\r\n\t\t\t// Assume e.length is constant or at least doesn't deviate to infinite or NaN.\r\n\t\t\tthrowIfEndless(!isFinite(max) && !isFinite(e.length));\r\n\t\t\tlet i = 0;\r\n\t\t\twhile(i<Math.min(e.length, max))\r\n\t\t\t{\r\n\t\t\t\tif(action(e[i], i++)===false)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn i;\r\n\t\t}\r\n\r\n\r\n\t\tif(isEnumerator<T>(e))\r\n\t\t{\r\n\t\t\tthrowIfEndless(!isFinite(max) && e.isEndless);\r\n\r\n\t\t\tlet i = 0;\r\n\t\t\t// Return value of action can be anything, but if it is (===) false then the forEach will discontinue.\r\n\t\t\twhile(max>i && e.moveNext())\r\n\t\t\t{\r\n\t\t\t\tif(action(<any>e.current, i++)===false)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn i;\r\n\t\t}\r\n\r\n\t\tif(isEnumerable<T>(e))\r\n\t\t{\r\n\t\t\tthrowIfEndless(!isFinite(max) && e.isEndless);\r\n\r\n\t\t\t// For enumerators that aren't EnumerableBase, ensure dispose is called.\r\n\t\t\treturn using(\r\n\t\t\t\t(<IEnumerable<T>>e).getEnumerator(),\r\n\t\t\t\tf=>forEach(f, action, max)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif(isIterator<T>(e))\r\n\t\t{\r\n\t\t\t// For our purpose iterators are endless and a max must be specified before iterating.\r\n\t\t\tthrowIfEndless(!isFinite(max));\r\n\r\n\t\t\tlet i = 0, r:IIteratorResult<T>;\r\n\t\t\t// Return value of action can be anything, but if it is (===) false then the forEach will discontinue.\r\n\t\t\twhile(max>i && !(r = e.next()).done)\r\n\t\t\t{\r\n\t\t\t\tif(action(<any>r.value, i++)===false)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n\r\n}\r\n\r\n/**\r\n * Converts any enumerable to an array.\r\n * @param source\r\n * @param max Stops after max is reached.  Allows for forEach to be called on infinite enumerations.\r\n * @returns {any}\r\n */\r\nexport function toArray<T>(\r\n\tsource:ForEachEnumerable<T>,\r\n\tmax:number = Infinity):T[]\r\n{\r\n\tif(<any>source===STRING_EMPTY) return [];\r\n\r\n\tif(!isFinite(max) && (source)instanceof(Array))\r\n\t\treturn source.slice();\r\n\r\n\tconst result:T[] = initArrayFrom(source, max);\r\n\tif(-1===forEach(source, (e, i) => { result[i] = e; }, max))\r\n\t\tthrow new UnsupportedEnumerableException();\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Converts any enumerable to an array of selected values.\r\n * @param source\r\n * @param selector\r\n * @param max Stops after max is reached.  Allows for forEach to be called on infinite enumerations.\r\n * @returns {TResult[]}\r\n */\r\n\r\nexport function map<T,TResult>(\r\n\tsource:ForEachEnumerable<T>,\r\n\tselector:SelectorWithIndex<T,TResult>,\r\n\tmax:number = Infinity):TResult[]\r\n{\r\n\tif(<any>source===STRING_EMPTY) return [];\r\n\r\n\tif(!isFinite(max) && (source)instanceof(Array))\r\n\t\treturn source.map(selector);\r\n\r\n\tconst result:TResult[] = initArrayFrom(source, max);\r\n\tif(-1===forEach(source, (e, i) => { result[i] = selector(e, i); }, max))\r\n\t\tthrow new UnsupportedEnumerableException();\r\n\r\n\treturn result;\r\n}"]}