{"version":3,"sources":["System/Collections/Array/Procedure.ts"],"names":[],"mappings":"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","file":"Procedure.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nexport function sum(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn 0;\r\n\r\n\tlet result = 0;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n)) result += n;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n)) return NaN;\r\n\t\t\tresult += n;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nexport function average(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tlet result = 0, count:number;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tcount = 0;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult += n;\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcount = source.length;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n)) return NaN;\r\n\t\t\tresult += n;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (!count || isNaN(result)) ? NaN : (result/count);\r\n}\r\n\r\nexport function product(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tlet result = 1;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tlet found = false;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n)){\r\n\t\t\t\tresult *= n;\r\n\t\t\t\tfound = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!found)\r\n\t\t\treturn NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n)) return NaN;\r\n\t\t\tresult *= n;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes the first number and divides it by all following.\r\n * @param source\r\n * @param ignoreNaN Will cause this skip any NaN values.\r\n * @returns {number}\r\n */\r\nexport function quotient(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tconst len = source ? source.length : 0;\r\n\tif(len<2)\r\n\t\treturn NaN;\r\n\r\n\tlet result = source[0];\r\n\r\n\tlet found = false;\r\n\tfor(let i=1;i<len;i++)\r\n\t{\r\n\t\tlet n = source[i];\r\n\t\tif(n===0)\r\n\t\t{\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\t\tif(isNaN(n))\r\n\t\t{\r\n\t\t\tif(!ignoreNaN)\r\n\t\t\t{\r\n\t\t\t\treturn NaN;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult /= n;\r\n\t\t\tif(!found) found = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn found ? result : NaN;\r\n}\r\n\r\n\r\nfunction ifSet(\r\n\tsource:ArrayLike<number>,\r\n\tstart:number,\r\n\tignoreNaN:boolean,\r\n\tpredicate:(n:number, result:number) => boolean):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tlet result = start;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tlet found = false;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tif(predicate(n, result))\r\n\t\t\t\t\tresult = n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!found)\r\n\t\t\treturn NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n))\r\n\t\t\t\treturn NaN;\r\n\r\n\t\t\tif(predicate(n, result))\r\n\t\t\t\tresult = n;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function min(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, +Infinity, ignoreNaN, (n, result) => n<result);\r\n}\r\n\r\nexport function max(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, -Infinity, ignoreNaN, (n, result) => n>result);\r\n}\r\n"]}