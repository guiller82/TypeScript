{"version":3,"sources":["System/Events/EventDispatcherBase.ts"],"names":[],"mappings":"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","file":"EventDispatcherBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as AU from \"../Collections/Array/Utility\";\r\nimport {shallowCopy} from \"../Utility/shallowCopy\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {dispose} from \"../Disposable/dispose\";\r\nimport {IEventListener} from \"./IEventListener\";\r\nimport {EventDispatcherEntry} from \"./EventDispatcherEntry\";\r\nimport {IEventDispatcher} from \"./IEventDispatcher\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string  = 'disposed';\r\n\r\n// The following interfaces are exported for sub class implementation.\r\n\r\nexport interface IEventBase<TTarget>\r\n{\r\n\ttype:string;\r\n\ttarget:TTarget;\r\n}\r\n\r\nexport interface IEvent extends IEventBase<any>\r\n{\r\n\r\n}\r\n\r\nexport interface IEntryParams\r\n{\r\n\tpriority:number;\r\n\tdispatcher:EventDispatcherBase;\r\n}\r\n\r\nfunction entryFinalizer()\r\n{\r\n\t//@ts-ignore\r\n\tconst _:EventDispatcherEntry<IEntryParams> = <any>this;\r\n\tconst p = _.params;\r\n\tconst d = p && p.dispatcher;\r\n\tif(d)\r\n\t{\r\n\t\td.removeEntry(_);\r\n\t\t(<any>p).dispatcher = null;\r\n\t}\r\n}\r\n\r\nconst NAME = \"EventDispatcherBase\";\r\n\r\nexport default\r\nclass EventDispatcherBase extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tconstructor() {\r\n\t\tsuper(NAME);\r\n\t}\r\n\r\n\tprotected _entries:EventDispatcherEntry<IEntryParams>[]|undefined;\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void\r\n\t{\r\n\t\tlet e = this._entries;\r\n\t\tif(!e) this._entries = e = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\te.push(\r\n\t\t\tnew EventDispatcherEntry(type, listener, {\r\n\t\t\t\t\tpriority: priority || 0,\r\n\t\t\t\t\tdispatcher: this\r\n\t\t\t\t},\r\n\t\t\t\tentryFinalizer));\r\n\t}\r\n\r\n\tremoveEntry(entry:EventDispatcherEntry<IEntryParams>):boolean\r\n\t{\r\n\t\treturn !!this._entries && AU.remove(this._entries, entry)!=0;\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener))\r\n\t\t\tthis.addEventListener(type, listener, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:IEventListener):boolean\r\n\t{\r\n\t\tconst e = this._entries;\r\n\t\treturn e && e.some(\r\n\t\t\t\t(value:EventDispatcherEntry<IEntryParams>):boolean =>\r\n\t\t\t\ttype==value.type && (!listener || listener==value.listener)\r\n\t\t\t) || false;\r\n\t}\r\n\r\n\tremoveEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener):void\r\n\t{\r\n\t\tconst e = this._entries;\r\n\t\tif(e) dispose.these.noCopy(e.filter(entry=> entry.matches(type, listener)));\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:IEvent):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\r\n\r\n\t\tlet l = _._entries;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tlet event:IEventBase<any>;\r\n\r\n\t\tif(typeof e=='string')\r\n\t\t{\r\n\t\t\tevent = <any>(Event && Object.create(Event) || {});\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tif(params['cancellable'])\r\n\t\t\t\t(<any>event).cancellable = true;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = e;\r\n\r\n\t\tconst type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tconst entries:EventDispatcherEntry<IEntryParams>[] = l.filter(e => e.type==type);//, propagate = true, prevent = false;\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort((a, b)=>\r\n\t\t\t(b.params ? b.params.priority : 0)\r\n\t\t\t- (a.params ? a.params.priority : 0)\r\n\t\t);\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\tentry=>\r\n\t\t\t{\r\n\t\t\t\tconst newEvent:any = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.dispatch(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean\r\n\t{\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose()\r\n\t{\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tconst _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing)\r\n\t\t{\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tconst l = _._entries;\r\n\t\t\tif(l)\r\n\t\t\t{\r\n\t\t\t\tthis._entries = <any>null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}