{"version":3,"sources":["System/Disposable/dispose.ts"],"names":[],"mappings":"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","file":"dispose.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\nimport {IDisposable} from \"./IDisposable\";\r\n\r\n// Allows for more flexible parameters.\r\nexport type DisposableItem = IDisposable|null|undefined;\r\nexport type DisposableItemArray = Array<DisposableItem>|null|undefined;\r\n\r\n/**\r\n * Takes any number of disposables as arguments and attempts to dispose them.\r\n * Any exceptions thrown within a dispose are not trapped.\r\n * Use 'disposeWithoutException' to automatically trap exceptions.\r\n *\r\n * Can accept <any> and will ignore objects that don't have a dispose() method.\r\n * @param disposables\r\n */\r\nexport function dispose(...disposables:DisposableItem[]):void\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\tdisposeTheseInternal(disposables, false);\r\n}\r\n\r\nexport module dispose\r\n{\r\n\r\n\t/**\r\n\t * Use this when only disposing one object to avoid creation of arrays.\r\n\t * @param disposable\r\n\t * @param trapExceptions\r\n\t */\r\n\texport function single(disposable:DisposableItem, trapExceptions:boolean = false):void\r\n\t{\r\n\t\tif(disposable)\r\n\t\t\tdisposeSingle(disposable,trapExceptions);\r\n\t}\r\n\r\n\texport function deferred(...disposables:DisposableItem[]):void\r\n\t{\r\n\t\tthese.deferred(disposables);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Takes any number of disposables and traps any errors that occur when disposing.\r\n\t * Returns an array of the exceptions thrown.\r\n\t * @param disposables\r\n\t * @returns {any[]} Returns an array of exceptions that occurred, if there are any.\r\n\t */\r\n\texport function withoutException(...disposables:DisposableItem[]):any[]|undefined\r\n\t{\r\n\t\t// The disposables arguments array is effectively localized so it's safe.\r\n\t\treturn disposeTheseInternal(disposables, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an array of disposable objects and ensures they are disposed.\r\n\t * @param disposables\r\n\t * @param trapExceptions If true, prevents exceptions from being thrown when disposing.\r\n\t * @returns {any[]} If 'trapExceptions' is true, returns an array of exceptions that occurred, if there are any.\r\n\t */\r\n\texport function these(disposables:DisposableItemArray, trapExceptions?:boolean):any[]|undefined\r\n\t{\r\n\t\treturn disposables && disposables.length\r\n\t\t\t? disposeTheseInternal(disposables.slice(), trapExceptions)\r\n\t\t\t: void 0;\r\n\t}\r\n\r\n\texport module these\r\n\t{\r\n\t\texport function deferred(disposables:DisposableItemArray, delay:number = 0):void\r\n\t\t{\r\n\t\t\tif(disposables && disposables.length)\r\n\t\t\t{\r\n\t\t\t\tif(!(delay>=0)) delay = 0;\r\n\t\t\t\tsetTimeout(disposeTheseInternal, delay, disposables.slice(), true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Use this unsafe method when guaranteed not to cause events that will make modifications to the disposables array.\r\n\t\t * @param disposables\r\n\t\t * @param trapExceptions\r\n\t\t * @returns {any[]}\r\n\t\t */\r\n\t\texport function noCopy(disposables:DisposableItemArray, trapExceptions?:boolean):any[]|undefined\r\n\t\t{\r\n\t\t\treturn disposables && disposables.length\r\n\t\t\t\t? disposeTheseInternal(disposables, trapExceptions)\r\n\t\t\t\t: void 0;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Just like in C# this 'using' function will ensure the passed disposable is disposed when the closure has finished.\r\n *\r\n * Usage:\r\n * ```typescript\r\n * using(new DisposableObject(),(myObj)=>{\r\n     *   // do work with myObj\r\n     * });\r\n * // myObj automatically has it's dispose method called.\r\n * ```\r\n *\r\n * @param disposable Object to be disposed.\r\n * @param closure Function call to execute.\r\n * @returns {TReturn} Returns whatever the closure's return value is.\r\n */\r\nexport function using<TDisposable extends IDisposable,TReturn>(\r\n\tdisposable:TDisposable,\r\n\tclosure:(disposable:TDisposable) => TReturn):TReturn\r\n{\r\n\ttry\r\n\t{\r\n\t\treturn closure(disposable);\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tdisposeSingle(disposable, false);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This private function makes disposing more robust for when there's no type checking.\r\n * If trapExceptions is 'true' it catches and returns any exception instead of throwing.\r\n */\r\nfunction disposeSingle(\r\n\tdisposable:IDisposable,\r\n\ttrapExceptions:boolean):any\r\n{\r\n\tif(\r\n\t\tdisposable\r\n\t\t&& typeof disposable==Type.OBJECT\r\n\t\t&& typeof disposable['dispose'] == \"function\"\r\n\t)\r\n\t{\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposable.dispose();\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\treturn ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tdisposable.dispose();\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * This dispose method assumes it's working on a local arrayCopy and is unsafe for external use.\r\n */\r\nfunction disposeTheseInternal(\r\n\tdisposables:DisposableItemArray,\r\n\ttrapExceptions?:boolean,\r\n\tindex:number = 0):any[]|undefined\r\n{\r\n\tlet exceptions:any[]|undefined;\r\n\tconst len = disposables ? disposables.length : 0;\r\n\r\n\tfor(; index<len; index++)\r\n\t{\r\n\t\tlet next = disposables![index];\r\n\t\tif(!next) continue;\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\tconst ex = disposeSingle(next, true);\r\n\t\t\tif(ex)\r\n\t\t\t{\r\n\t\t\t\tif(!exceptions) exceptions = [];\r\n\t\t\t\texceptions.push(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet success = false;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposeSingle(next, false);\r\n\t\t\t\tsuccess = true;\r\n\t\t\t}\r\n\t\t\t\t// Don't trap the exception in order to allow it to propagate the stack trace.\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tif(!success && index + 1<len)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* If code is 'continued' by the debugger,\r\n\t\t\t\t\t * need to ensure the rest of the disposables are cared for. */\r\n\t\t\t\t\tdisposeTheseInternal(disposables, false, index + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Just in case...  Should never happen, but asserts the intention.\r\n\t\t\tif(!success) break;\r\n\t\t}\r\n\t}\r\n\r\n\treturn exceptions;\r\n}\r\n\r\nexport default dispose;"]}