{"version":3,"sources":["System/Lazy.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAIH,+CAA4C;AAC5C,sCAAyC;AACzC,oCAAoC;AACpC,IAAM,SAAS,GAAG,iBAAe,CAAC;AAGlC,0EAA0E;AAC1E;IAA6B,wBAAe;IAG3C,cAAY,YAAoB,EAAE,cAA8B,EAAE,UAA0B;QAA1D,+BAAA,EAAA,sBAA8B;QAAE,2BAAA,EAAA,kBAA0B;QAA5F,YAEC,kBAAM,YAAY,EAAE,cAAc,EAAE,UAAU,CAAC,SAI/C;QAHA,qCAAqC;QACrC,KAAI,CAAC,qBAAqB,GAAG,MAAM,CAAC;QACpC,KAAI,CAAC,eAAe,GAAG,KAAK,CAAC;;IAC9B,CAAC;IAED,sBAAI,gCAAc;aAAlB;YAEC,OAAO,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC;QAC/B,CAAC;;;OAAA;IAED,sBAAI,uBAAK;aAAT;YAEC,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC;;;OAAA;IAED,qBAAM,GAAN,UAAO,KAAa;QAEnB,OAAO,IAAI,IAAE,KAAK,CAAC;IACpB,CAAC;IAED,0BAAW,GAAX,UAAY,KAAa;QAExB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,KAAG,KAAK,CAAC,KAAK,CAAC;IACvD,CAAC;IAEM,WAAM,GAAb,UAAiB,YAAoB,EAAE,cAA8B,EAAE,UAA0B;QAA1D,+BAAA,EAAA,sBAA8B;QAAE,2BAAA,EAAA,kBAA0B;QAEhG,OAAO,IAAI,IAAI,CAAI,YAAY,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IAC9D,CAAC;IAEF,WAAC;AAAD,CApCA,AAoCC,CApC4B,2BAAY,GAoCxC;AApCY,oBAAI;AAsCjB;IAAuC,kCAAO;IAE7C,wBAAY,YAAoB,EAAE,cAA8B;QAA9B,+BAAA,EAAA,sBAA8B;QAAhE,YAEC,kBAAM,YAAY,EAAE,cAAc,EAAE,IAAI,CAAC,SAGzC;QAFA,qCAAqC;QACrC,KAAI,CAAC,qBAAqB,GAAG,gBAAgB,CAAC;;IAC/C,CAAC;IAEM,qBAAM,GAAb,UAAiB,YAAoB,EAAE,cAA8B;QAA9B,+BAAA,EAAA,sBAA8B;QAEpE,OAAO,IAAI,cAAc,CAAI,YAAY,EAAE,cAAc,CAAC,CAAC;IAC5D,CAAC;IACF,qBAAC;AAAD,CAbA,AAaC,CAbsC,IAAI,GAa1C;AAbY,wCAAc;AAe3B,kBAAe,IAAI,CAAC","file":"Lazy.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ILazy} from \"./ILazy\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ResolverBase} from \"./ResolverBase\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n// We need a non-resettable lazy to ensure it can be passed safely around.\r\nexport class Lazy<T> extends ResolverBase<T> implements ILazy<T>\r\n{\r\n\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, allowReset);\r\n\t\t// @ts-ignore // Force this override.\r\n\t\tthis._disposableObjectName = 'Lazy';\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tget isValueCreated():boolean\r\n\t{\r\n\t\treturn !!this._isValueCreated;\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this.getValue();\r\n\t}\r\n\r\n\tequals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this==other;\r\n\t}\r\n\r\n\tvalueEquals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this.equals(other) || this.value===other.value;\r\n\t}\r\n\r\n\tstatic create<T>(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\treturn new Lazy<T>(valueFactory, trapExceptions, allowReset);\r\n\t}\r\n\r\n}\r\n\r\nexport class ResettableLazy<T> extends Lazy<T>\r\n{\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, true);\r\n\t\t// @ts-ignore // Force this override.\r\n\t\tthis._disposableObjectName = 'ResettableLazy';\r\n\t}\r\n\r\n\tstatic create<T>(valueFactory:Func<T>, trapExceptions:boolean = false)\r\n\t{\r\n\t\treturn new ResettableLazy<T>(valueFactory, trapExceptions);\r\n\t}\r\n}\r\n\r\nexport default Lazy;"]}